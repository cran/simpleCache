<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Nathan Sheffield" />

<meta name="date" content="2026-02-27" />

<title>An introduction to simpleCache</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/rstudio/markdown/inst/resources/prism-xcode.css" data-external="1">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/yihui/knitr/inst/misc/vignette.css" data-external="1">
<script src="https://cdn.jsdelivr.net/combine/npm/@xiee/utils/js/code-lang.min.js,npm/@xiee/utils/js/number-captions.min.js,npm/prismjs@1.29.0/components/prism-core.min.js" data-external="1" defer></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js" data-external="1" defer></script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>











</head>

<body>




<h1 class="title toc-ignore">An introduction to simpleCache</h1>
<h4 class="author">Nathan Sheffield</h4>
<h4 class="date">2026-02-27</h4>



<div id="an-introduction-to-simplecache" class="section level1">
<h1>An introduction to simpleCache</h1>
<div id="your-first-cache" class="section level2">
<h2>Your first cache</h2>
<p><code>simpleCache</code> has 2 main use cases: First, it can help you
pick up where you left off in an R session, and second, it can help you
parallelize code by enabling you to share results across R sessions.</p>
<p>The workhorse of <code>simpleCache</code> is the eponymous
<code>simpleCache()</code> function, which in the simplest case requires
just two parameters: a cache name, and a block of code. The cache name
should be considered unique and its underlying object immutable, while
the block of code (or <em>instruction</em>) is the <code>R</code> code
that generates the object you wish to cache.</p>
<p>But before we start creating caches, it’s important to tell
<code>simpleCache</code> where to store the caches.
<code>simpleCache</code> uses a global variable
(<code>RCACHE.DIR</code>) for caches, and provides a setter function
(<code>setCacheDir()</code>) to change this. To get started, choose a
cache directory, and generate some random data.</p>
<pre class="r"><code>library(simpleCache)
cacheDir = tempdir()
setCacheDir(cacheDir)
simpleCache(&quot;normSamp&quot;, { rnorm(1e7, 0,1) })</code></pre>
<pre><code>## ::Creating cache::   /tmp/RtmpXJsAAF/normSamp.RData</code></pre>
<p>Now, watch what happens when we run that same function call
again:</p>
<pre class="r"><code>simpleCache(&quot;normSamp&quot;, { rnorm(1e7, 0,1) })</code></pre>
<pre><code>## ::Object exists (in .GlobalEnv)::    normSamp</code></pre>
<p>Notice that the second call to <code>simpleCache()</code> doesn’t
re-run the <code>rnorm</code> calculation. In fact, it doesn’t even
re-load the cache, because it notices that it’s already in memory. If
the cache weren’t already in memory, this call would load it from disk.
This means you can put this code in multiple scripts and pull the same
randomized data, without re-doing the compute work.</p>
<p>You can also force a cache to reload using the <code>reload</code>
option. This could be useful, for example, if you’ve loaded a cache and
then accidentally changed it, and want to reset. By default, a call to
<code>simpleCache()</code> will not reload an object that already exists
in your environment. But you can always force it with the
<code>reload</code> parameter:</p>
<pre class="r"><code>normSamp = NA  # Oops broke my object in memory.
# Regular call won&#39;t reload because we have an object called normSamp already:
simpleCache(&quot;normSamp&quot;, { rnorm(1e7, 0,1) })</code></pre>
<pre><code>## ::Object exists (in .GlobalEnv)::    normSamp</code></pre>
<pre class="r"><code># But we can force reload and get it back with reload=TRUE
simpleCache(&quot;normSamp&quot;, { rnorm(1e7, 0,1) }, reload=TRUE)</code></pre>
<pre><code>## ::Loading cache::    /tmp/RtmpXJsAAF/normSamp.RData</code></pre>
<p>What if we want to start over and blow that cache, getting a new
random set? Use the <code>recreate</code> flag if you want to ensure
that the cache is produced and overwritten even if it already
exists:</p>
<pre class="r"><code>simpleCache(&quot;normSamp&quot;, { rnorm(1e7, 0,1) }, recreate=TRUE)</code></pre>
<pre><code>## ::Creating cache::   /tmp/RtmpXJsAAF/normSamp.RData</code></pre>
<p>With just those parameters (cache name, instruction, recreate, and
reload), you should be able to make good use of
<code>simpleCache</code>. The essence is: if the object exists in memory
already: do nothing. If it does not exist in memory, but exists on disk:
load it into memory. If it exists neither in memory or on disk: create
it and store it to disk and memory. Now you’ve got the basics.</p>
<p>But there’s more if you want it: read on!</p>
</div>
<div id="comparison-to-base-r-save-and-load" class="section level2">
<h2>Comparison to base R save() and load()</h2>
<p>Of course, R has base functions that accomplish this
(<code>save()</code> and <code>load()</code>), so what does simpleCache
add? Well, <code>simpleCache</code> is essentially a convenience wrapper
around the base R functions. The first advantage is that we now require
only a single function: <code>simpleCache()</code> handles both saving
and loading. This means your script does not need to be written
differently depending on whether it’s generating or loading a cache,
because the same function can do either, depending on whether the cache
exists or not. The second advantage is that caches are keyed by cache
name instead of by filename. So instead of putting a whole path to an
Rdata file into <code>load()</code>, we just pass a unique identifier
for the cache, and simpleCache handles the rest. Third,
<code>simpleCache</code> tries to be smart: if you already have the
object in memory, it won’t re-load it. For big caches, this can save you
time if you accidentally call <code>simpleCache()</code> multiple times
on the same cache (or if you write functions to populate an R
environment with a bunch of pre-existing data).</p>
<p>Beyond that, <code>simpleCache</code> also offers several convenient
options that just make it really easy to save and re-load R objects.
Let’s go into a bit more detail into these features.</p>
</div>
<div id="cache-names" class="section level2">
<h2>Cache names</h2>
<p>By default, the object will be loaded into a variable with the same
name as the cache. You can change this behavior with the
<code>assignTo</code> parameter:</p>
<pre class="r"><code>simpleCache(&quot;normSamp&quot;, { rnorm(1e7, 0,1) }, assignTo=&quot;mySamp&quot;)</code></pre>
<pre><code>## ::Object exists (in .GlobalEnv)::    normSamp</code></pre>
<p>After doing this command, we have both <code>normSamp</code> (from
the previous calls, not from this one) and <code>mySamp</code> (loaded
in this call) in the workspace, and these objects are identical:</p>
<pre class="r"><code>identical(normSamp, mySamp)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>This <code>assignTo</code> concept is useful if you want to create
caches but not load them, or load caches one at a time. Which leads us
to…</p>
</div>
<div id="creating-but-not-loading-caches" class="section level2">
<h2>Creating but not loading caches</h2>
<p>It may be that you want to create a bunch of caches that are quite
memory intensive, and you don’t actually need them all in this
particular R workspace at the same time. If you just create each object
and save it, you’ll end with all those objects in memory at the same
time. Instead, you can use the <code>noload</code> parameter, which will
create the caches but not load them into memory (so the object will be
cached, but will not persist in this R environment). I use this
frequently in a setup script to build caches that I will need later in
individual scripts that will run on each one individually. Let’s make 5
caches but not load them:</p>
<pre class="r"><code>for (i in 1:5) {
    cacheName = paste0(&quot;normSamp_&quot;, i)
    simpleCache(cacheName, { rnorm(1e6, 0,1) }, recreate=TRUE, noload=TRUE)
}</code></pre>
<pre><code>## ::Creating cache::   /tmp/RtmpXJsAAF/normSamp_1.RData</code></pre>
<pre><code>## ::Creating cache::   /tmp/RtmpXJsAAF/normSamp_2.RData</code></pre>
<pre><code>## ::Creating cache::   /tmp/RtmpXJsAAF/normSamp_3.RData</code></pre>
<pre><code>## ::Creating cache::   /tmp/RtmpXJsAAF/normSamp_4.RData</code></pre>
<pre><code>## ::Creating cache::   /tmp/RtmpXJsAAF/normSamp_5.RData</code></pre>
<p>We’ve now produced 5 different sample data caches. They exist on
disk, but not in memory. This could, for example, be done in an initial
data-generation or setup script. We then may be interested in using
these (same) caches in several downstream scripts, and we could do some
iterative operation on them and use <code>assignTo</code> to avoid
loading more than 1 at a time into memory:</p>
<pre class="r"><code>overallMinimum = 1e6  # pick some high number to start
for (i in 1:5) {
    cacheName = paste0(&quot;normSamp_&quot;, i)
    simpleCache(cacheName, assignTo=&quot;temp&quot;)
    overallMinimum = min(overallMinimum, temp)
}</code></pre>
<pre><code>## ::Loading cache::    /tmp/RtmpXJsAAF/normSamp_1.RData</code></pre>
<pre><code>## ::Loading cache::    /tmp/RtmpXJsAAF/normSamp_2.RData</code></pre>
<pre><code>## ::Loading cache::    /tmp/RtmpXJsAAF/normSamp_3.RData</code></pre>
<pre><code>## ::Loading cache::    /tmp/RtmpXJsAAF/normSamp_4.RData</code></pre>
<pre><code>## ::Loading cache::    /tmp/RtmpXJsAAF/normSamp_5.RData</code></pre>
<pre class="r"><code>message(overallMinimum)</code></pre>
<pre><code>## -4.74769784411471</code></pre>
<p>In this code block, by assigning the caches to the variable
<code>temp</code>, we only have 1 in memory at a time, because each
cache load overwrites the previous one, which is exactly what we want in
this case. We keep track of the minimum value of each one independently,
and we’ve effectively calculated an overall minimum while loading only a
single cache in memory at a time.</p>
</div>
<div id="loading-multiple-caches" class="section level2">
<h2>Loading multiple caches</h2>
<p>If you’ve got a bunch of caches and you want them all in memory, you
could just load all the caches into memory with this convenience
alias:</p>
<pre class="r"><code>loadCaches(paste0(&quot;normSamp_&quot;, 1:5))</code></pre>
<pre><code>## ::Loading cache::    /tmp/RtmpXJsAAF/normSamp_1.RData</code></pre>
<pre><code>## ::Loading cache::    /tmp/RtmpXJsAAF/normSamp_2.RData</code></pre>
<pre><code>## ::Loading cache::    /tmp/RtmpXJsAAF/normSamp_3.RData</code></pre>
<pre><code>## ::Loading cache::    /tmp/RtmpXJsAAF/normSamp_4.RData</code></pre>
<pre><code>## ::Loading cache::    /tmp/RtmpXJsAAF/normSamp_5.RData</code></pre>
<p>The disadvantage of doing it this way is that you’ve lost the
advantage of using the single <code>simpleCache()</code> function for
both saving and loading, but this may be desirable in some cases.</p>
<p>By the way, once a cache is created, you no longer need to provide
instructions:</p>
<pre class="r"><code>simpleCache(&quot;normSamp&quot;)</code></pre>
<pre><code>## ::Object exists (in .GlobalEnv)::    normSamp</code></pre>
<p><code>simpleCache</code> will load it if it can; if not, it will give
you an error saying it requires an <code>instruction</code>.</p>
</div>
<div id="timing-cache-creating" class="section level2">
<h2>Timing cache creating</h2>
<p>If you want to record how long it takes to create a new cache, you
can set <code>timer=TRUE</code>.</p>
<pre class="r"><code>simpleCache(&quot;normSamp&quot;, { rnorm(1e6, 0,1) }, recreate=TRUE, timer=TRUE)</code></pre>
<pre><code>## ::Creating cache::   /tmp/RtmpXJsAAF/normSamp.RData</code></pre>
<pre><code>## &lt;00h 00m 0.0s&gt;</code></pre>
</div>
<div id="complicated-code" class="section level2">
<h2>Complicated code</h2>
<p>So far, our examples have cached the result of a very simple
instruction code block: the <code>rnorm</code> call to randomly generate
some numbers. But really, simpleCache can be used to cache anything. The
code block can be whatever you want; whatever it returns will be cached.
For example, let’s cache the result of a call to
<code>t.test()</code>:</p>
<pre class="r"><code>simpleCache(&quot;tResult&quot;, { 
    dat2 = rnorm(1e5, 0.05,2)
    t.test(normSamp, dat2)
    }, recreate=TRUE)</code></pre>
<pre><code>## ::Creating cache::   /tmp/RtmpXJsAAF/tResult.RData</code></pre>
<pre class="r"><code>tResult</code></pre>
<pre><code>## 
##  Welch Two Sample t-test
## 
## data:  normSamp and dat2
## t = -8.2201, df = 105028, p-value &lt; 2.2e-16
## alternative hypothesis: true difference in means is not equal to 0
## 95 percent confidence interval:
##  -0.06531687 -0.04016585
## sample estimates:
##    mean of x    mean of y 
## 0.0005271108 0.0532684711</code></pre>
<pre class="r"><code>tResult$p.value</code></pre>
<pre><code>## [1] 2.055639e-16</code></pre>
<p>The point is that the code could be quite complicated and
time-consuming. You may only want to calculate it once, and then re-use
the result in another script – or in this same script next time you run
it. <code>simpleCache</code> makes that, well, simple.</p>
<p>That’s the end of the basics. There are a few more advanced options
as well, such as using a shared cache directory, submitting compute
requests to a cluster using <code>batchtools</code>, tweaking the
loading environment with the <code>loadEnvir</code> parameter (if you
need to call <code>simpleCache()</code> from within a function), and
tweaking the cache building resources with the <code>buildEnvir</code>
parameter. But these options are more advanced and probably not needed
for 95% of <code>simpleCache</code> use cases. If you do need more
information, you can find further help in the other vignettes or in the
detailed R function documentation (see <code>?simpleCache</code>).</p>
<pre class="r"><code>deleteCaches(&quot;normSamp&quot;, force=TRUE)</code></pre>
<pre><code>## Deleting /tmp/RtmpXJsAAF/normSamp.RData</code></pre>
<pre class="r"><code>deleteCaches(paste0(&quot;normSamp_&quot;, 1:5), force=TRUE)</code></pre>
<pre><code>## Deleting /tmp/RtmpXJsAAF/normSamp_1.RData</code></pre>
<pre><code>## Deleting /tmp/RtmpXJsAAF/normSamp_2.RData</code></pre>
<pre><code>## Deleting /tmp/RtmpXJsAAF/normSamp_3.RData</code></pre>
<pre><code>## Deleting /tmp/RtmpXJsAAF/normSamp_4.RData</code></pre>
<pre><code>## Deleting /tmp/RtmpXJsAAF/normSamp_5.RData</code></pre>
<pre class="r"><code>deleteCaches(&quot;tResult&quot;, force=TRUE)</code></pre>
<pre><code>## Deleting /tmp/RtmpXJsAAF/tResult.RData</code></pre>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
